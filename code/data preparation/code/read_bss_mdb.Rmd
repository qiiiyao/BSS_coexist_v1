---
title: "read_mdb"
author: "Qi yao"
date: "2024-07-26"
output: html_document
---

```{python}
import csv, pyodbc
import pandas as pd
import numpy as np

[x for x in pyodbc.drivers() if x.startswith("Microsoft Access Driver")]

# set up some constants
MDB = 'D:/R projects/BSS/data/BSS_2023/BSS Database 2023.mdb'
DRV = '{Microsoft Access Driver (*.mdb, *.accdb)}'
PWD = 'pw'

# connect to db
con = pyodbc.connect('DRIVER={};DBQ={};PWD={}'.format(DRV,MDB,PWD))
cur = con.cursor()

# Function to list all tables in the database
def list_tables(cursor):
    tables = []
    for row in cursor.tables(tableType='TABLE'):
        tables.append(row.table_name)
    return tables
  
def extract_table_data(cursor, table_name):
    try:
        # Define the SQL query to extract data from the specified table
        sql_query = f'SELECT * FROM [{table_name}]'
        # Execute the SQL query
        cursor.execute(sql_query)
        # Fetch all results from the executed query
        rows = cursor.fetchall()
        # Get the column names from the cursor description
        columns = [desc[0] for desc in cursor.description]
        # Convert the results into a DataFrame
        df = pd.DataFrame.from_records(rows, columns=columns)
        return df
    except Exception as e:
        print(f"Error extracting data from table {table_name}: {e}")
        raise

  
tables = list_tables(cur)
data = extract_table_data(cur, 'DATA')
total = extract_table_data(cur, 'Total')
age = extract_table_data(cur, 'age')
years = extract_table_data(cur, 'years')
fields = extract_table_data(cur, 'FIELDS') ### meta-data
leaf_nutrients = extract_table_data(cur, tables[3])
species = extract_table_data(cur, 'SPECIES')
trait = extract_table_data(cur, 'TRAIT DATA') ### trait-data

merged_data_1 = pd.merge(data, age, on=['FIELDID','YEARID'], how='inner')
merged_data_2 = pd.merge(merged_data_1, years, on=['YEARID'], how='inner')
merged_data_3 = pd.merge(merged_data_2, species[['SPECIESID', 'FAMILY', 'GENUS', 'EPITHET']],
                         on=['SPECIESID'], how='left')
merged_data_3.columns
merged_data_3['species'] = merged_data_3['GENUS'].astype(str) + '_' + merged_data_3['EPITHET'].astype(str)
merged_data_3.iloc[1]
merged_data_3_wide = pd.pivot_table(merged_data_3,index=['YEARID', 'FIELDID',
                                                'PLOTID','AGE',
                                                'YEAR'],
                                    columns='species',values='COVER')
merged_data_3_wide = merged_data_3_wide.reset_index()
merged_data_3_wide.iloc[1]    

merged_data_3_wide.to_csv('D:/R projects/BSS/data/BSS_data_2023/community_data_wide.csv', index=True)  # Includes the index
merged_data_3.to_csv('D:/R projects/BSS/data/BSS_data_2023/community_data_long.csv', index=True)  # Includes the index

fields.to_csv('D:/R projects/BSS/data/BSS_data_2023/fields.csv', index=True)  # Includes the index

trait.to_csv('D:/R projects/BSS/data/BSS_data_2023/traits.csv', index=True)  # Includes the index

```


```{r}
rm(list = ls())
require(dplyr)
require(tidyr)
require(readr)
require(stringr)
require(ape)
require(phytools)
require(taxize)

### Calculate the original functional distance
tree = read.tree('D:/R projects/BSS/data/original data/phylo_tree332.txt')

community = read_csv("D:/R projects/BSS/data/BSS_data_2023/community_data_wide.csv",
                     show_col_types = FALSE)
community_long = read_csv("D:/R projects/BSS/data/BSS_data_2023/community_data_long.csv",
                     show_col_types = FALSE)
max_ages = community %>% group_by(FIELDID) %>% summarise_at('AGE', max) %>% arrange(AGE)
pre_sps = which(colSums(community[,c(7:ncol(community))], na.rm = T) != 0)
community_c = cbind(community[,1:6], community[,names(pre_sps)])
sps_c = colnames(community_c)[7:ncol(community_c)]
sps_c = gsub(' \\_', '\\_', sps_c)
sps_cc = gsub('sp\\.', 'sp', sps_c)
colnames(community_c)[7:ncol(community_c)] = sps_cc

sps_long = community_long$species
sps_longc = gsub(' \\_', '\\_', sps_long)
sps_longcc = gsub('sp\\.', 'sp', sps_longc)
community_long$species = sps_longcc

lack_sps = setdiff(colnames(community_c)[7:ncol(community_c)], tree$tip.label)

# Filter elements containing 'sp', 'none', or ' '
lack_sps_c = lack_sps[!grepl("none|None|nan| ", lack_sps)]
lack_sps_cc = lack_sps_c[!grepl("sp", lack_sps_c)]


#add to the family root####
community_long_c = community_long %>% filter(species %in% lack_sps_c)
df.species.add.to.genus = community_long_c[,c("species","FAMILY","GENUS")] %>% unique()
names(df.species.add.to.genus)=c('Taxon','family','genus')

GENUS = community_long_c$GENUS %>% unique()
phylo = tree
for(i in 1:length(GENUS)){
  #si = 6
  genus_ = GENUS[i]
  try({
    print(paste(i, '/483 genus starts at', Sys.time(), length(phylo$tip.label)))
    x0=phylo$tip.label[str_starts(phylo$tip.label, paste0(genus_, "_"))]# the existing tip.label of the genus in the backbone phyloneny
    species.to.addtotree = filter(df.species.add.to.genus, genus == genus_)$Taxon # the tip label of the species to be added to phylogney
    # if there is only one species in the genus of the phylogeny, the subtree (many species to add) or the tip (one species to add) will be added to the postion of the half edge. Accorddingly, the new edge length will also be half 
    # I first faked a sister species for the tip if the tip is the only tip of the genus in the phylogeny
    # then the missing species will be added to the new ancester node of the two tip (real and fake)
    if(length(x0) == 1){
      z0=grep(x0, phylo$tip.label) # the existing species of the relevant genus
      x0.half.length= 0.5*phylo$edge.length[which(phylo$edge[,2]==z0)]
      fake.species = paste(x0,'thisisafakespeciess',sep='')
      phylo = bind.tip(tree = phylo,
                        tip.label = fake.species,
                        edge.length = x0.half.length,
                        where = z0, 
                        position = x0.half.length)
      x0 = c(x0, fake.species)
    }
    to.drop = setdiff(phylo$tip.label, x0) # subtree only with existing species of the genus
    new.tree.this.genus = drop.tip(phylo, to.drop) # subtree only with existing species of the genus
    # check for outlier of the genus
    
    new.species.edge.length = max(cophenetic(new.tree.this.genus))/2
    y0=findMRCA(phylo, x0) # the most recent ancestor node of the existing species of the genus
    
    # when many species to add, they will be added as a polytomy using bind.tree; if only one species, use bind.tip
    if(length(species.to.addtotree)>1){
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)
    }else{
      species.to.addtotree = c(species.to.addtotree, paste0(species.to.addtotree,"thisisafakespeciess"))
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)    
    }
  })
  
}


## drop the fake tip.label####
to.drop = str_subset(phylo$tip.label, "thisisafakespeciess")
phylo.new=drop.tip(phylo, to.drop)
lack_sps_c2 = setdiff(lack_sps_c, phylo.new$tip.label)


write.tree(phylo.new,
     file = 'D:/R projects/BSS/data/BSS_data_2023/phylo_tree378.newick')


#add to the family root: 8 species' families are not even existed in the tree !!!####
e1.add.famliy = community_long_c %>% filter(species %in% lack_sps_c2)
df.species.add.to.famliy = e1.add.famliy[,c("species","FAMILY","GENUS")] %>% unique()
names(df.species.add.to.famliy)=c('Taxon','family','genus')

Families.not.found = df.species.add.to.famliy$family %>% unique()
#phylo = phylo.DNC.project

family_info = tax_name(sci = gsub('_', ' ', lack_sps_c2), get = "family", db = "itis")

# Combine the species and family information
phy_all = data.frame(
  Species = lack_sps_c2,
  Family = family_info$family,
  stringsAsFactors = FALSE
)

# now add these species
phylo = phylo.new
for(i in 1:length(Families.not.found)){
  i = 5
  family_ = Families.not.found[i]
  try({
    print(paste(i, '/47 famliy starts at', Sys.time(), length(phylo$tip.label)))
    x0 = phylo %>% filter(FAMILY == family_) %>% pull(species) %>% unique() # the existing tip.label of the genus in the backbone phyloneny
    
    species.to.addtotree = filter(df.species.add.to.famliy, family == family_)$Taxon # the tip label of the species to be added to phylogney
    if(length(x0)>1000){
      x0 = sample(x0, 1000)
    }
    if(length(x0) == 1){
      z0=grep(x0, phylo$tip.label) # the existing species of the relevant family
      x0.half.length= 0.5*phylo$edge.length[which(phylo$edge[,2]==z0)]
      fake.species = paste(x0,'thisisafakespeciess',sep='')
      phylo = bind.tip(tree = phylo,
                        tip.label = fake.species,
                        edge.length = x0.half.length,
                        where = z0, 
                        position = x0.half.length)
      x0 = c(x0, fake.species)
    }
    to.drop = setdiff(phylo$tip.label, x0) # subtree only with existing species of the genus
    new.tree.this.genus = drop.tip(phylo, to.drop) # subtree only with existing species of the genus
    # check for outlier of the genus
    
    new.species.edge.length = max(cophenetic(new.tree.this.genus))/2
    y0=findMRCA(phylo, x0) # the most recent ancestor node of the existing species of the genus
    
    # when many species to add, they will be added as a polytomy using bind.tree; if only one species, use bind.tip
    if(length(species.to.addtotree)>1){
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)
    }else{
      species.to.addtotree = c(species.to.addtotree, paste0(species.to.addtotree,"thisisafakespeciess"))
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)    
    }
  })
  
}
## drop the fake tip.label####

to.drop = str_subset(phylo$tip.label, "thisisafakespeciess")
phylo.DNC.add.genus.family =drop.tip(phylo, to.drop)





```
