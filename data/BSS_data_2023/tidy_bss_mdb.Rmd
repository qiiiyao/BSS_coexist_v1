---
title: "read_mdb"
author: "Qi yao"
date: "2024-07-26"
output: html_document
---

```{python}
import csv, pyodbc
import pandas as pd
import numpy as np

[x for x in pyodbc.drivers() if x.startswith("Microsoft Access Driver")]

# set up some constants
MDB = 'D:/R projects/BSS/data/BSS_2023/BSS Database 2023.mdb'
DRV = '{Microsoft Access Driver (*.mdb, *.accdb)}'
PWD = 'pw'

# connect to db
con = pyodbc.connect('DRIVER={};DBQ={};PWD={}'.format(DRV,MDB,PWD))
cur = con.cursor()

# Function to list all tables in the database
def list_tables(cursor):
    tables = []
    for row in cursor.tables(tableType='TABLE'):
        tables.append(row.table_name)
    return tables
  
def extract_table_data(cursor, table_name):
    try:
        # Define the SQL query to extract data from the specified table
        sql_query = f'SELECT * FROM [{table_name}]'
        # Execute the SQL query
        cursor.execute(sql_query)
        # Fetch all results from the executed query
        rows = cursor.fetchall()
        # Get the column names from the cursor description
        columns = [desc[0] for desc in cursor.description]
        # Convert the results into a DataFrame
        df = pd.DataFrame.from_records(rows, columns=columns)
        return df
    except Exception as e:
        print(f"Error extracting data from table {table_name}: {e}")
        raise

  
tables = list_tables(cur)
data = extract_table_data(cur, 'DATA')
total = extract_table_data(cur, 'Total')
age = extract_table_data(cur, 'age')
years = extract_table_data(cur, 'years')
fields = extract_table_data(cur, 'FIELDS') ### meta-data
leaf_nutrients = extract_table_data(cur, tables[3])
species = extract_table_data(cur, 'SPECIES')
trait = extract_table_data(cur, 'TRAIT DATA') ### trait-data

merged_data_1 = pd.merge(data, age, on=['FIELDID','YEARID'], how='inner')
merged_data_2 = pd.merge(merged_data_1, years, on=['YEARID'], how='inner')
merged_data_3 = pd.merge(merged_data_2, species[['SPECIESID', 'FAMILY', 'GENUS', 'EPITHET']],
                         on=['SPECIESID'], how='left')
merged_data_3.columns
merged_data_3['species'] = merged_data_3['GENUS'].astype(str) + '_' + merged_data_3['EPITHET'].astype(str)
merged_data_3.iloc[1]
merged_data_3_wide = pd.pivot_table(merged_data_3,index=['YEARID', 'FIELDID',
                                                'PLOTID','AGE',
                                                'YEAR'],
                                    columns='species', values='COVER',
                                    aggfunc='sum')
merged_data_3_wide.columns    
print(merged_data_3_wide.columns.tolist())
column_sum = merged_data_3_wide['Leersia_virginica'].sum()

merged_data_3_wide = merged_data_3_wide.reset_index()
merged_data_3_wide.iloc[1]    

merged_data_3_wide.to_csv('D:/R projects/BSS/data/BSS_data_2023/community_data_wide.csv',
                          index=True)  # Includes the index
merged_data_3.to_csv('D:/R projects/BSS/data/BSS_data_2023/community_data_long.csv', index=True)  # Includes the index

fields.to_csv('D:/R projects/BSS/data/BSS_data_2023/fields.csv', index=True)  # Includes the index

trait.to_csv('D:/R projects/BSS/data/BSS_data_2023/traits.csv', index=True)  # Includes the index

```


```{r}
rm(list = ls())
setwd("D:/R projects/BSS")
require(dplyr)
require(data.table)
require(tidyr)
require(stringr)
require(readr)
require(ape)
require(phytools)
require(U.Taxonstand)

### load the required data
load("data/Plants_TPL.rdata")
tree = read.tree('data/original data/phylo_tree332.txt')

### don't use read_r function in readr, might enconutering some problems.
community = read.csv("data/BSS_data_2023/community_data_wide.csv",
                     header = T)
community_long = read.csv("data/BSS_data_2023/community_data_long.csv",
                     header = T)
traits = read.csv("data/BSS_data_2023/traits.csv",
                     header = T)

community_long$DATAID = paste(community_long$FIELDID, community_long$PLOTID,
                              community_long$AGE, community_long$YEAR,
                              sep = '_')

community_2 = community_long[,c("DATAID", 'FIELDID', 'PLOTID', 'YEAR', 'AGE',
                                "species","COVER")] %>%
              tidyr::pivot_wider(names_from = species,
              values_from = COVER,
              values_fn = sum) # using sum fn to merge the cover from various stems at same species

traits$species = paste(traits$GENUS, traits$EPITHET, sep = '_')
traits_1 = traits %>% relocate(species, .after = EPITHET)

## standardized the species name of trait data
standardized_names_traits = nameMatch(spList=gsub('_', ' ',traits$species),
                               spSource=database, author = TRUE, max.distance= 1)
standardized_names_traits$Accepted_SPNAME_2 = sapply(strsplit(standardized_names_traits$Accepted_SPNAME, ' '),
                                                   function(x){y = x[2]
                                                               if (is.na(y)){
                                                                 y1 = paste0(x[1], '_sp')
                                                                 } else {
                                                                 y1 = paste(x, collapse = '_')
                                                                 }
                                                   return(y1)})
standardized_names_traits$Submitted_Name = traits$species
traits_2 = traits_1 %>% left_join(standardized_names_traits[,c("Submitted_Name",
                    "Accepted_SPNAME_2")], by = join_by(species == Submitted_Name) ) %>% 
           relocate(Accepted_SPNAME_2, .after = 'species')

save(traits_2, file = 'D:/R projects/BSS/data/BSS_data_2023/traits_tidy.rdata')

## compare the wide data and the long data results to validate our data collation
pre_sps = which(sort(colSums(community[,c(7:ncol(community))], na.rm = T)) != 0)
pre_sps_2 = which(sort(colSums(community_2[,c(6:ncol(community_2))], na.rm = T)) != 0)

community_c = cbind(community[,1:6], community[,names(pre_sps)])
sps_c = colnames(community_c)[7:ncol(community_c)]

sps_long_u = unique(community_long$species)

standardized_names_comm = nameMatch(spList=gsub('_', ' ',sps_long_u),
                               spSource=database, author = TRUE, max.distance= 1)
standardized_names_comm$Accepted_SPNAME_2 = sapply(strsplit(standardized_names_comm$Accepted_SPNAME, ' '),
                                                   function(x){y = x[2]
                                                               if (is.na(y)){
                                                                 y1 = paste0(x[1], '_sp')
                                                                 } else {
                                                                 y1 = paste(x, collapse = '_')
                                                                 }
                                                   return(y1)})
standardized_names_comm$Submitted_Name = sps_long_u

community_long_1 = community_long %>% left_join(standardized_names_comm[,c("Submitted_Name",
                    "Accepted_SPNAME_2")], by = join_by(species == Submitted_Name) )
unique((community_long_1 %>% filter(is.na(Accepted_SPNAME_2)))$species)

standardized_names_phy = nameMatch(spList=gsub('_', ' ',tree$tip.label),
                               spSource=database, author = TRUE, max.distance= 1)
standardized_names_phy$Accepted_SPNAME_2 = sapply(strsplit(standardized_names_phy$Accepted_SPNAME, ' '),
                                                   function(x){y = x[2]
                                                               if (is.na(y)){
                                                                 y1 = paste0(x[1], '_sp')
                                                                 } else {
                                                                 y1 = paste(x, collapse = '_')
                                                                 }
                                                   return(y1)})
tree$tip.label = standardized_names_phy$Accepted_SPNAME_2
lack_sps = setdiff(standardized_names_comm$Accepted_SPNAME_2,
                   standardized_names_phy$Accepted_SPNAME_2)
lack_sps
sort(lack_sps)
sort(tree$tip.label)

# Filter elements containing 'sp', 'none', or ' '
lack_sps_c = lack_sps[!grepl("none|None|nan", lack_sps)]
lack_sps[grepl("none|None|nan|", lack_sps)]

#firstly convert to ultrametric tree, then add.species.to.genus
# Generate a random tree to use 
tree.1 = force.ultrametric(tree, method = "nnls")
tree.2 = add.species.to.genus(tree.1,lack_sps_c[1],where="root")
lack_sps_c_2 = c()
for (i in 2:length(lack_sps_c)) {
    #i = 2
  result = tryCatch(
    {add.species.to.genus(tree.2,lack_sps_c[i],where="root")
      NULL  },
     warning = function(w) {
      # If a warning is returned, print the element
      message("Warning for element: ", lack_sps_c[i])
      lack_sps_c[i]  # Return the element
    }
  )
  if (!is.null(result)) {
    print(result)
    lack_sps_c_2 = c(lack_sps_c_2, result)
  }
}
lack_sps_c_1 = setdiff(lack_sps_c, lack_sps_c_2)

tree.2 = add.species.to.genus(tree.1,lack_sps_c_1[1],where="root")
for (i in 2:length(lack_sps_c_1)) {
    #i = 2
  result = tryCatch(
    {add.species.to.genus(tree.2,lack_sps_c_1[i],where="root")
      NULL  },
     warning = function(w) {
      # If a warning is returned, print the element
      message("Warning for element: ", lack_sps_c_1[i])
      lack_sps_c_1[i]  # Return the element
    }
  )
  if (!is.null(result)) {
    print(result)
  }
}

community_long_c = community_long_1 %>% filter(Accepted_SPNAME_2 %in% lack_sps_c)

## Strictly checked, this new data indeed have many new genus_sp type's species

#add to the family root####
df.species.add.to.genus = community_long_c[,c("Accepted_SPNAME_2","FAMILY","GENUS")] %>% unique()
names(df.species.add.to.genus)=c('Taxon','family','genus')

GENUS = community_long_c$GENUS %>% unique()
phylo = tree
for(i in 1:length(GENUS)){
  #i = 6
  genus_ = GENUS[i]
  try({
    print(paste(i, '/483 genus starts at', Sys.time(), length(phylo$tip.label)))
    x0=phylo$tip.label[str_starts(phylo$tip.label, paste0(genus_, "_"))]# the existing tip.label of the genus in the backbone phyloneny
    species.to.addtotree = filter(df.species.add.to.genus, genus == genus_)$Taxon # the tip label of the species to be added to phylogney
    # if there is only one species in the genus of the phylogeny, the subtree (many species to add) or the tip (one species to add) will be added to the postion of the half edge. Accorddingly, the new edge length will also be half 
    # I first faked a sister species for the tip if the tip is the only tip of the genus in the phylogeny
    # then the missing species will be added to the new ancester node of the two tip (real and fake)
    if(length(x0) == 1){
      z0=grep(x0, phylo$tip.label) # the existing species of the relevant genus
      x0.half.length= 0.5*phylo$edge.length[which(phylo$edge[,2]==z0)]
      fake.species = paste(x0,'thisisafakespeciess',sep='')
      phylo = bind.tip(tree = phylo,
                        tip.label = fake.species,
                        edge.length = x0.half.length,
                        where = z0, 
                        position = x0.half.length)
      x0 = c(x0, fake.species)
    }
    to.drop = setdiff(phylo$tip.label, x0) # subtree only with existing species of the genus
    new.tree.this.genus = drop.tip(phylo, to.drop) # subtree only with existing species of the genus
    # check for outlier of the genus
    
    new.species.edge.length = max(cophenetic(new.tree.this.genus))/2
    y0=findMRCA(phylo, x0) # the most recent ancestor node of the existing species of the genus
    
    # when many species to add, they will be added as a polytomy using bind.tree; if only one species, use bind.tip
    if(length(species.to.addtotree)>1){
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)
    }else{
      species.to.addtotree = c(species.to.addtotree, paste0(species.to.addtotree,"thisisafakespeciess"))
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)    
    }
  })
  
}


## drop the fake tip.label####
to.drop = str_subset(phylo$tip.label, "thisisafakespeciess")
phylo.new=drop.tip(phylo, to.drop)
lack_sps_c2 = setdiff(lack_sps_c, phylo.new$tip.label)

sort(lack_sps_c2)
sort(phylo.new$tip.label) ## 425 species

community_long_newsps = community_long_1 %>% filter(Accepted_SPNAME_2 %in% lack_sps_c2)
traits_newsps = traits_2 %>% filter(Accepted_SPNAME_2 %in% lack_sps_c2)

community_long_1$DATAID = paste(community_long_1$FIELDID, community_long_1$PLOTID,
                              community_long_1$AGE, community_long_1$YEAR,
                              sep = '_')

community_long_1 = community_long_1[,c("DATAID", 'FIELDID', 'PLOTID', 'YEAR', 'AGE',
                                "Accepted_SPNAME_2", "COVER")] %>% 
              filter(Accepted_SPNAME_2 != 'NA_sp')

community_wide_1 = community_long_1[,c("DATAID", 'FIELDID', 'PLOTID', 'YEAR', 'AGE',
                                "Accepted_SPNAME_2", "COVER")] %>% 
              tidyr::pivot_wider(names_from = Accepted_SPNAME_2,
              values_from = COVER,
              values_fn = sum) # using sum fn to merge the cover from various stems at same species


save(community_wide_1, file = 'D:/R projects/BSS/data/BSS_data_2023/community_wide_tidy.rdata')
save(community_long_1, file = 'D:/R projects/BSS/data/BSS_data_2023/community_long_tidy.rdata')
write.tree(phylo.new,
     file = 'D:/R projects/BSS/data/BSS_data_2023/phylo_tree426.newick')



#add to the family root: 19 species' families are not even existed in the tree, 
# five of these are ferns !!! ####
e1.add.famliy = community_long_c %>% filter(species %in% lack_sps_c2)
df.species.add.to.famliy = e1.add.famliy[,c("species","FAMILY","GENUS")] %>% unique()
names(df.species.add.to.famliy)=c('Taxon','family','genus')

Families.not.found = df.species.add.to.famliy$family %>% unique()
#phylo = phylo.DNC.project

family_info = tax_name(sci = phylo.new$tip.label, get = "family", db = "itis",
                       rows = 1)
family_info_none = family_info %>% filter(is.na(family))
family_info_2 = tax_name(sci = family_info_none$query, get = "family", db = "ncbi",
                       rows = 1)
family_info_none_2 = family_info_2 %>% filter(is.na(family))

tax_name(sci = phylo.new$tip.label[1], get = "order", db = "ncbi",
                       rows = 1)
tax_name(sci = lack_sps_c2, get = "family", db = "itis",
                       rows = 1)
# Combine the species and family information
phy_all = data.frame(
  Species = family_info$query,
  Family = family_info$family,
  stringsAsFactors = FALSE
)

# now add these species
phylo = phylo.new
for(i in 1:length(Families.not.found)){
  i = 1
  family_ = Families.not.found[i]
  try({
    print(paste(i, '/47 famliy starts at', Sys.time(), length(phylo$tip.label)))
    x0 = community_long_c %>% filter(FAMILY == family_) %>% pull(species) %>% unique() # the existing tip.label of the genus in the backbone phyloneny
    
    species.to.addtotree = filter(df.species.add.to.famliy, family == family_)$Taxon # the tip label of the species to be added to phylogney
    if(length(x0)>1000){
      x0 = sample(x0, 1000)
    }
    if(length(x0) == 1){
      z0=grep(x0, phylo$tip.label) # the existing species of the relevant family
      x0.half.length= 0.5*phylo$edge.length[which(phylo$edge[,2]==z0)]
      fake.species = paste(x0,'thisisafakespeciess',sep='')
      phylo = bind.tip(tree = phylo,
                        tip.label = fake.species,
                        edge.length = x0.half.length,
                        where = z0, 
                        position = x0.half.length)
      x0 = c(x0, fake.species)
    }
    to.drop = setdiff(phylo$tip.label, x0) # subtree only with existing species of the genus
    new.tree.this.genus = drop.tip(phylo, to.drop) # subtree only with existing species of the genus
    # check for outlier of the genus
    
    new.species.edge.length = max(cophenetic(new.tree.this.genus))/2
    y0=findMRCA(phylo, x0) # the most recent ancestor node of the existing species of the genus
    
    # when many species to add, they will be added as a polytomy using bind.tree; if only one species, use bind.tip
    if(length(species.to.addtotree)>1){
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)
    }else{
      species.to.addtotree = c(species.to.addtotree, paste0(species.to.addtotree,"thisisafakespeciess"))
      subtree.to.add = read.tree(text=paste('[&R] (',
                                             paste(paste(species.to.addtotree, new.species.edge.length,sep = ':'),collapse = ','),
                                             ');',sep = ''))
      phylo = bind.tree(phylo, subtree.to.add, where = y0, position = 0)    
    }
  })
  
}
## drop the fake tip.label####

to.drop = str_subset(phylo$tip.label, "thisisafakespeciess")
phylo.new2 =drop.tip(phylo, to.drop)
unique(phylo.new2$tip.label)

lack_sps_c3 = setdiff(lack_sps_c2, phylo.new2$tip.label)



```
